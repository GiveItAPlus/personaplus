/* <=============================================================================>
 *  PersonaPlus - Give yourself a plus!
 *  Copyright (C) 2023-2025 The "Give It A Plus" organization and the PersonaPlus contributors. All rights reserved.
 *  Distributed under the terms of the GNU General Public License version 3.0.
 *  See the LICENSE file in the root of this repository for more details.
 * <=============================================================================>
 *
 * You are in: @/toolkit/objectives/passive_objectives.ts
 * Basically: Objectives are one of the most important parts of the app, and this toolkit contains all the base functions to interact with PASSIVE objectives.
 *
 * <=============================================================================>
 */

import { TFunction } from "i18next";
import {
    CreateObjective,
    DeleteObjective,
    GetAllObjectives,
    GetGenericObjectiveDailyLog,
    GetObjective,
    GetPendingGenericObjectives,
    SaveGenericObjectiveDailyLog,
} from "@/toolkit/objectives/common";
import type {
    PassiveObjective,
    PassiveObjectiveDailyLog,
    PassiveObjectiveWithoutId,
} from "@/types/passive_objectives";
import { TodaysDate, ValidateTodaysDateString } from "@/types/today";
import { GetCurrentDateCorrectly, JavaScriptifyTodaysDate } from "../today";
import { ShowToast } from "../android";
import AsyncStorage from "expo-sqlite/kv-store";
import StoredItemNames from "@/constants/stored_item_names";
import { AllObjectivesPendingReturn } from "@/types/common_objectives";

/**
 * Creates a passive objective and saves it. You need to provide all the data for it (except the ID) as an `PassiveObjectiveWithoutId` object.
 *
 * @async
 * @param {PassiveObjectiveWithoutId} target A passive objective with everything EXCEPT it's ID. Identifier is generated by the own function.
 * @param {TFunction} t Pass here the translate function, please.
 * @returns {Promise<void>} 0 if success, 1 if failure.
 */
async function CreatePassiveObjective(
    target: PassiveObjectiveWithoutId,
    t: TFunction,
): Promise<void> {
    return await CreateObjective(target, "passive", t);
}

/**
 * Edits a Passive Objective, overwriting it's data.
 *
 * @async
 * @param {PassiveObjectiveWithoutId} obj Data WITHOUT ID of the new objective (what content you'll use for overwriting).
 * @param {number} id ID of the objective to overwrite.
 * @param {TFunction} t Pass here the translate function, please.
 * @returns {Promise<void>} 0 if success, 1 if failure.
 */
async function EditPassiveObjective(
    obj: PassiveObjectiveWithoutId,
    id: number,
    t: TFunction,
): Promise<void> {
    try {
        const oldObj: PassiveObjective | null = await GetObjective(
            id,
            "passive",
        );

        if (!oldObj) throw new Error(`No active objective with ID ${id}`);

        const newObjective: PassiveObjective = {
            ...oldObj, // 1st go the oldies
            ...obj, // 2nd go the overrides
            identifier: id, // 3rd goes the ID override
        };

        let objs: PassiveObjective[] | null = await GetAllObjectives("passive");
        if (!objs || objs.length === 0) objs = [];

        const index: number = objs.findIndex(
            (o: PassiveObjective): boolean => o.identifier === id,
        );

        if (index !== -1) {
            // overwrite
            objs[index] = newObjective;
        } else {
            // this shouldn't happen
            throw new Error(
                `Objective with ID ${id} not found in the objectives list!`,
            );
        }

        try {
            await AsyncStorage.setItem(
                StoredItemNames.activeObjectives,
                JSON.stringify(objs),
            );
            ShowToast(
                t("pages.createActiveObjective.doneFeedback", {
                    obj: newObjective.goal,
                }),
            );
            console.log(
                `Edited ${newObjective.goal} objective with ID ${newObjective.identifier} successfully!\nFull JSON of the new objective:\n${JSON.stringify(
                    newObjective,
                )}"`,
            );
        } catch (e) {
            throw new Error(`Failed to save objectives! ${e}`);
        }
    } catch (e) {
        ShowToast("Error :c");
        throw new Error(
            `Something went wrong editing passive objective ${id}.\n\nError: ${e}`,
        );
    }
}

/**
 * Returns the objectives from AsyncStorage as an `PassiveObjective[]`, or `null` if there aren't any objectives.
 *
 * @async
 * @returns {Promise<PassiveObjective[] | null>} - Returns the objectives as an `Objective[]`.
 */
async function GetAllPassiveObjectives(): Promise<PassiveObjective[] | null> {
    return await GetAllObjectives("passive");
}

/**
 * Returns the user's `PassiveObjectiveDailyLog`.
 *
 * @returns {PassiveObjectiveDailyLog} The entire daily log, or an empty object if it doesn't exist.
 */
async function GetPassiveObjectiveDailyLog(): Promise<PassiveObjectiveDailyLog> {
    return await GetGenericObjectiveDailyLog("passive");
}

/**
 * Retrieves a single objective from AsyncStorage by its identifier.
 *
 * @async
 * @param {number} identifier - The unique identifier of the objective to retrieve.
 * @returns {Promise<PassiveObjective | null>} - Returns the objective if found, otherwise null.
 */
async function GetPassiveObjective(
    identifier: number,
): Promise<PassiveObjective | null> {
    return await GetObjective(identifier, "passive");
}

/**
 * Deletes a specific passive objective from the AsyncStorage, given it's identifier.
 *
 * @async
 * @param {number} identifier The identifier.
 * @returns {Promise<void>}
 */
async function DeletePassiveObjective(identifier: number): Promise<void> {
    await DeleteObjective(identifier, "passive");
}

/**
 * Saves a passive objective to a daily registry.
 *
 * @async
 * @param {number} id ID of the objective
 * @param {boolean} wasDone Whether the objective was done or not.
 * @returns {Promise<void>}
 */
async function SavePassiveObjectiveToDailyLog(
    id: number,
    wasDone: boolean,
): Promise<void> {
    try {
        // Fetch old data
        const dailyData: PassiveObjectiveDailyLog =
            await GetPassiveObjectiveDailyLog();
        const today: TodaysDate = GetCurrentDateCorrectly().string;
        const objective: PassiveObjective | null =
            await GetPassiveObjective(id);

        if (!objective) throw new Error(`${id} is a wrong identifier.`);

        // If there's no old data for today, creates an {} for today
        if (!dailyData[today]) dailyData[today] = {};

        // Saves the objective data
        dailyData[today][id] = {
            wasDone: wasDone,
            objective: objective,
        };

        // Updates data and puts it back to AsyncStorage
        await SaveGenericObjectiveDailyLog(dailyData, "passive");
        console.log(`Marked passive obj ${id} as done for ${today}.`);
    } catch (e) {
        throw new Error(`Error saving user's goal for objective ${id}: ${e}`);
    }
}

/**
 * Tells you if the user has any passive objective due today or not. If he does, returns all of them, as an `number[]` being each number the ID of each active objective.
 *
 * @async
 * @returns {Promise<AllObjectivesPendingReturn>} Either an array with pending objective identifiers _only_ or a text-based code indicating context.
 */
async function GetPendingPassiveObjectives(): Promise<AllObjectivesPendingReturn> {
    return await GetPendingGenericObjectives("passive");
}

/**
 * Gets the user's streak on a passive objective.
 *
 * @async
 * @param {number} identifier Identifier of the objective.
 * @returns {Promise<number>} The number of days in a row the user's been complying with this passive objective.
 */
async function GetPassiveObjectiveStreak(identifier: number): Promise<number> {
    const log: PassiveObjectiveDailyLog = await GetPassiveObjectiveDailyLog();
    // no log no streak
    if (!log) return 0;

    let currentDate: Date = new Date();
    currentDate.setUTCHours(23, 59, 0, 0);
    // 00:00:00:00 is also an option, consider it in case this fails

    type entry = [string, { [identifier: number]: { wasDone: boolean } }];

    // filter logs to only have the ones for the specified identifier
    const userLogs: { date: TodaysDate; wasDone: boolean }[] = Object.entries(
        log,
    )
        .filter(
            ([_, entry]: entry): boolean | undefined =>
                entry && entry[identifier] && entry[identifier].wasDone,
        )
        .filter(
            ([date, entry]: entry): boolean =>
                ValidateTodaysDateString(date) &&
                entry[identifier] !== undefined,
        )
        .map(
            ([date, entry]: entry): { date: TodaysDate; wasDone: boolean } => ({
                date: date as TodaysDate,
                wasDone: entry[identifier]!.wasDone,
            }),
        );

    // sort logs by date
    userLogs.sort(
        (a: { date: TodaysDate }, b: { date: TodaysDate }): number =>
            JavaScriptifyTodaysDate(a.date).getTime() -
            JavaScriptifyTodaysDate(b.date).getTime(),
    );

    let streak: number = 0;

    // loop thru all entries
    for (let i: number = userLogs.length - 1; i >= 0; i--) {
        const currentLog: { date: TodaysDate; wasDone: boolean } | undefined =
            userLogs[i];
        if (!currentLog) break;
        const logDate: Date = JavaScriptifyTodaysDate(currentLog.date);
        logDate.setUTCHours(23, 59, 0, 0);

        // check if the log is from yesterday
        // .floor to obviously get 1 or 2 days streak and not 1.42
        const diffDays: number = Math.ceil(
            (currentDate.getTime() - logDate.getTime()) / (1000 * 60 * 60 * 24),
        );

        if (diffDays === 1 && currentLog.wasDone) {
            streak += 1;
            currentDate = logDate;
        } else if (diffDays === 0) {
            continue; // we reached today, we can ignore
        } else {
            streak = 0;
            break; // if they failed, reset streak
        }
    }

    return streak;
}

export {
    CreatePassiveObjective,
    DeletePassiveObjective,
    GetPassiveObjective,
    EditPassiveObjective,
    GetAllPassiveObjectives,
    GetPassiveObjectiveStreak,
    GetPendingPassiveObjectives,
    GetPassiveObjectiveDailyLog,
    SavePassiveObjectiveToDailyLog,
};
