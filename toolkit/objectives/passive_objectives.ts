/* <=============================================================================>
 *  PersonaPlus - Give yourself a plus!
 *  Copyright (C) 2023-2026 The "Give It A Plus" organization and the PersonaPlus contributors. All rights reserved.
 *  Distributed under the terms of the GNU General Public License version 3.0.
 *  See the LICENSE file in the root of this repository for more details.
 * <=============================================================================>
 *
 * Objectives are one of the most important parts of the app, and this toolkit contains all the base functions to interact with PASSIVE objectives.
 *
 * <=============================================================================>
 */

import { TFunction } from "i18next";
import {
    CreateObjective,
    DeleteObjective,
    GetAllObjectives,
    GetGenericObjectiveDailyLog,
    GetObjective,
    GetPendingGenericObjectives,
    SaveGenericObjectiveDailyLog,
} from "@/toolkit/objectives/common";
import type {
    PassiveObjective,
    PassiveObjectiveDailyLog,
    PassiveObjectiveWithoutId,
} from "@/types/passive_objectives";
import { TodaysDate } from "@/types/today";
import {
    DifferenceInDays,
    GetCurrentDateCorrectly,
    JavaScriptifyTodaysDate,
} from "../today";
import { ShowToast } from "../android";
import AsyncStorage from "expo-sqlite/kv-store";
import StoredItemNames from "@/constants/stored_item_names";
import { AllObjectivesPendingReturn } from "@/types/common_objectives";

/**
 * Creates a passive objective and saves it. You need to provide all the data for it (except the ID) as an `PassiveObjectiveWithoutId` object.
 *
 * @async
 * @param {PassiveObjectiveWithoutId} target A passive objective with everything EXCEPT it's ID. Identifier is generated by the own function.
 * @param {TFunction} t Pass here the translate function, please.
 * @returns {Promise<void>} 0 if success, 1 if failure.
 */
async function CreatePassiveObjective(
    target: PassiveObjectiveWithoutId,
    t: TFunction,
): Promise<void> {
    return await CreateObjective(target, "passive", t);
}

/**
 * Edits a Passive Objective, overwriting it's data.
 *
 * @async
 * @param {PassiveObjectiveWithoutId} obj Data WITHOUT ID of the new objective (what content you'll use for overwriting).
 * @param {number} id ID of the objective to overwrite.
 * @param {TFunction} t Pass here the translate function, please.
 * @returns {Promise<void>} 0 if success, 1 if failure.
 */
async function EditPassiveObjective(
    obj: PassiveObjectiveWithoutId,
    id: number,
    t: TFunction,
): Promise<void> {
    try {
        const oldObj: PassiveObjective | null = await GetObjective(
            id,
            "passive",
        );

        if (!oldObj) throw new Error(`No active objective with ID ${id}`);

        const newObjective: PassiveObjective = {
            ...oldObj, // 1st go the oldies
            ...obj, // 2nd go the overrides
            id, // 3rd goes the ID override
        };

        let objs: PassiveObjective[] | null = await GetAllObjectives("passive");
        if (!objs || objs.length === 0) objs = [];

        const index: number = objs.findIndex(
            (o: PassiveObjective): boolean => o.id === id,
        );

        if (index !== -1) {
            // overwrite
            objs[index] = newObjective;
        } else {
            // this shouldn't happen
            throw new Error(
                `Objective with ID ${id} not found in the objectives list!`,
            );
        }

        try {
            await AsyncStorage.setItem(
                StoredItemNames.activeObjectives,
                JSON.stringify(objs),
            );
            ShowToast(
                t("pages.createActiveObjective.doneFeedback", {
                    obj: newObjective.goal,
                }),
            );
            console.log(
                `Edited ${newObjective.goal} objective with ID ${newObjective.id} successfully!\nFull JSON of the new objective:\n${JSON.stringify(
                    newObjective,
                )}"`,
            );
        } catch (e) {
            throw new Error(`Failed to save objectives! ${e}`);
        }
    } catch (e) {
        ShowToast("Error :c");
        throw new Error(
            `Something went wrong editing passive objective ${id}.\n\nError: ${e}`,
        );
    }
}

/**
 * Returns the objectives from AsyncStorage as an `PassiveObjective[]`, or `null` if there aren't any objectives.
 *
 * @async
 * @returns {Promise<PassiveObjective[] | null>} - Returns the objectives as an `Objective[]`.
 */
async function GetAllPassiveObjectives(): Promise<PassiveObjective[] | null> {
    return await GetAllObjectives("passive");
}

/**
 * Returns the user's `PassiveObjectiveDailyLog`.
 *
 * @returns {PassiveObjectiveDailyLog} The entire daily log, or an empty object if it doesn't exist.
 */
async function GetPassiveObjectiveDailyLog(): Promise<PassiveObjectiveDailyLog> {
    return await GetGenericObjectiveDailyLog("passive");
}

/**
 * Retrieves a single objective from AsyncStorage by its identifier.
 *
 * @async
 * @param {number} identifier - The unique identifier of the objective to retrieve.
 * @returns {Promise<PassiveObjective | null>} - Returns the objective if found, otherwise null.
 */
async function GetPassiveObjective(
    identifier: number,
): Promise<PassiveObjective | null> {
    return await GetObjective(identifier, "passive");
}

/**
 * Deletes a specific passive objective from the AsyncStorage, given it's identifier.
 *
 * @async
 * @param {number} identifier The identifier.
 * @returns {Promise<void>}
 */
async function DeletePassiveObjective(identifier: number): Promise<void> {
    await DeleteObjective(identifier, "passive");
}

/**
 * Saves a passive objective to a daily registry.
 *
 * @async
 * @param {number} id ID of the objective
 * @param {boolean} wasDone Whether the objective was done or not.
 * @returns {Promise<void>}
 */
async function SavePassiveObjectiveToDailyLog(
    id: number,
    wasDone: boolean,
): Promise<void> {
    try {
        // Fetch old data
        const dailyData: PassiveObjectiveDailyLog =
            await GetPassiveObjectiveDailyLog();
        const date: TodaysDate = GetCurrentDateCorrectly().string;
        const objective: PassiveObjective | null =
            await GetPassiveObjective(id);

        if (!objective) throw new Error(`${id} is a wrong identifier.`);

        // Saves the objective data
        dailyData.push({
            id,
            date,
            data: {
                wasDone,
                objective,
            },
        });

        // Updates data and puts it back to AsyncStorage
        await SaveGenericObjectiveDailyLog(dailyData, "passive");
        console.log(`Marked passive obj ${id} as done for ${date}.`);
    } catch (e) {
        throw new Error(`Error saving user's goal for objective ${id}: ${e}`);
    }
}

/**
 * Tells you if the user has any passive objective due today or not. If he does, returns all of them, as an `number[]` being each number the ID of each active objective.
 *
 * @async
 * @returns {Promise<AllObjectivesPendingReturn>} Either an array with pending objective identifiers _only_ or a text-based code indicating context.
 */
async function GetPendingPassiveObjectives(): Promise<AllObjectivesPendingReturn> {
    return await GetPendingGenericObjectives("passive");
}

/**
 * Gets the user's streak on a passive objective.
 *
 * @async
 * @param {number} id Identifier of the objective.
 * @returns {Promise<number>} The number of days in a row the user's been complying with this passive objective.
 */
async function GetPassiveObjectiveStreak(
    id: number,
    __log?: PassiveObjectiveDailyLog,
): Promise<number> {
    const log: PassiveObjectiveDailyLog =
        __log ?? (await GetPassiveObjectiveDailyLog());
    // no log no streak
    if (!log || log.length === 0) return 0;

    let currentDate: Date = new Date();

    // filter logs to only have the ones for the specified identifier
    const userLogs: PassiveObjectiveDailyLog = log
        .filter((entry) => entry.id === id)
        .sort(
            (a: { date: TodaysDate }, b: { date: TodaysDate }): number =>
                JavaScriptifyTodaysDate(b.date).getTime() -
                JavaScriptifyTodaysDate(a.date).getTime(),
        );

    let streak: number = 0;

    // loop thru all entries
    for (const currentLog of userLogs) {
        const logDate: Date = JavaScriptifyTodaysDate(currentLog.date);
        const diffDays: number = DifferenceInDays(currentDate, logDate);

        if (diffDays === 1 && currentLog.data.wasDone) {
            streak += 1;
            currentDate = logDate;
        } else if (diffDays === 0) {
            continue; // we reached today, we can ignore
        } else {
            streak = 0;
            break; // if they failed, reset streak
        }
    }

    return streak;
}

export {
    CreatePassiveObjective,
    DeletePassiveObjective,
    GetPassiveObjective,
    EditPassiveObjective,
    GetAllPassiveObjectives,
    GetPassiveObjectiveStreak,
    GetPendingPassiveObjectives,
    GetPassiveObjectiveDailyLog,
    SavePassiveObjectiveToDailyLog,
};
